// Code generated by metrics-generator. DO NOT EDIT.
//
//nolint:wrapcheck,lll
package metrics

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/samber/mo"

	"github.com/3Danger/currency/internal/repo/cashflowreg"
	"git.vseinstrumenti.net/fd/lib/metrics/upstreamwrap"
)

type repo struct {
	r cashflowreg.Repo
	w *upstreamwrap.Wrapper
}

func WithMetrics(r cashflowreg.Repo, w *upstreamwrap.Wrapper) cashflowreg.Repo {
	return &repo{r: r, w: w}
}

func (r *repo) BeginTx(ctx context.Context) (*sql.Tx, error) {
	t := time.Now()

	res0, err := r.r.BeginTx(ctx)

	r.w.Observe("begin_tx", err == nil, time.Since(t))

	return res0, err
}

func (r *repo) ListActiveDocs(ctx context.Context, orderGUIDs []uuid.UUID) ([]*cashflowreg.Item, error) {
	t := time.Now()

	res0, err := r.r.ListActiveDocs(ctx, orderGUIDs)

	r.w.Observe("list_active_docs", err == nil, time.Since(t))

	return res0, err
}

func (r *repo) ListActiveDocsByGUIDTx(ctx context.Context, tx *sql.Tx, guid uuid.UUID) ([]*cashflowreg.Item, error) {
	t := time.Now()

	res0, err := r.r.ListActiveDocsByGUIDTx(ctx, tx, guid)

	r.w.Observe("list_active_docs_by_guidtx", err == nil, time.Since(t))

	return res0, err
}

func (r *repo) ListDocsByOrdersTx(ctx context.Context, tx *sql.Tx, orderGUIDs []uuid.UUID) ([]*cashflowreg.Item, error) {
	t := time.Now()

	res0, err := r.r.ListDocsByOrdersTx(ctx, tx, orderGUIDs)

	r.w.Observe("list_docs_by_orders_tx", err == nil, time.Since(t))

	return res0, err
}

func (r *repo) ListDocsByOrdersAndTypes(ctx context.Context, orderGUIDs []uuid.UUID, docTypes ...cashflowreg.DocType) ([]*cashflowreg.Item, error) {
	t := time.Now()

	res0, err := r.r.ListDocsByOrdersAndTypes(ctx, orderGUIDs, docTypes...)

	r.w.Observe("list_docs_by_orders_and_types", err == nil, time.Since(t))

	return res0, err
}

func (r *repo) ListByReturnOrderAndTypeTx(ctx context.Context, tx *sql.Tx, orderGUID uuid.UUID, docType cashflowreg.DocType) ([]*cashflowreg.Item, error) {
	t := time.Now()

	res0, err := r.r.ListByReturnOrderAndTypeTx(ctx, tx, orderGUID, docType)

	r.w.Observe("list_by_return_order_and_type_tx", err == nil, time.Since(t))

	return res0, err
}

func (r *repo) ListByOrderAndTypeTx(ctx context.Context, tx *sql.Tx, orderGUID uuid.UUID, docType cashflowreg.DocType) ([]*cashflowreg.Item, error) {
	t := time.Now()

	res0, err := r.r.ListByOrderAndTypeTx(ctx, tx, orderGUID, docType)

	r.w.Observe("list_by_order_and_type_tx", err == nil, time.Since(t))

	return res0, err
}

func (r *repo) ListByOrderAndNotTypeTx(ctx context.Context, tx *sql.Tx, orderGUID uuid.UUID, docType cashflowreg.DocType) ([]*cashflowreg.Item, error) {
	t := time.Now()

	res0, err := r.r.ListByOrderAndNotTypeTx(ctx, tx, orderGUID, docType)

	r.w.Observe("list_by_order_and_not_type_tx", err == nil, time.Since(t))

	return res0, err
}

func (r *repo) GetDocumentTx(ctx context.Context, tx *sql.Tx, guid, orderGUID, lineID uuid.UUID) (mo.Option[cashflowreg.Item], error) {
	t := time.Now()

	res0, err := r.r.GetDocumentTx(ctx, tx, guid, orderGUID, lineID)

	r.w.Observe("get_document_tx", err == nil, time.Since(t))

	return res0, err
}

func (r *repo) InsertCashFlowRegisterTx(ctx context.Context, tx *sql.Tx, item cashflowreg.Item) error {
	t := time.Now()

	err := r.r.InsertCashFlowRegisterTx(ctx, tx, item)

	r.w.Observe("insert_cash_flow_register_tx", err == nil, time.Since(t))

	return err
}

func (r *repo) SetCashFlowRegisterDeletedTx(ctx context.Context, tx *sql.Tx, guid uuid.UUID) error {
	t := time.Now()

	err := r.r.SetCashFlowRegisterDeletedTx(ctx, tx, guid)

	r.w.Observe("set_cash_flow_register_deleted_tx", err == nil, time.Since(t))

	return err
}

func (r *repo) GetCashFlowRegisterActiveTx(ctx context.Context, tx *sql.Tx, guid uuid.UUID) (mo.Option[*cashflowreg.CashFlowRegister], error) {
	t := time.Now()

	res0, err := r.r.GetCashFlowRegisterActiveTx(ctx, tx, guid)

	r.w.Observe("get_cash_flow_register_active_tx", err == nil, time.Since(t))

	return res0, err
}

func (r *repo) GetDocumentByGUIDLineIDTx(ctx context.Context, tx *sql.Tx, guid, lineID uuid.UUID) (mo.Option[cashflowreg.Item], error) {
	t := time.Now()

	res0, err := r.r.GetDocumentByGUIDLineIDTx(ctx, tx, guid, lineID)

	r.w.Observe("get_document_by_guidline_idtx", err == nil, time.Since(t))

	return res0, err
}

func (r *repo) SetOrderGUIDTx(ctx context.Context, tx *sql.Tx, orderGUID, guid, lineID uuid.UUID) error {
	t := time.Now()

	err := r.r.SetOrderGUIDTx(ctx, tx, orderGUID, guid, lineID)

	r.w.Observe("set_order_guidtx", err == nil, time.Since(t))

	return err
}

func (r *repo) CountCashFlowRegByTypeFromCreationToday(ctx context.Context) (map[cashflowreg.DocType]int, error) {
	t := time.Now()

	res0, err := r.r.CountCashFlowRegByTypeFromCreationToday(ctx)

	r.w.Observe("count_cash_flow_reg_by_type_from_creation_today", err == nil, time.Since(t))

	return res0, err
}

func (r *repo) CountCashFlowRegByTypeFromReleaseYesterday(ctx context.Context) (map[cashflowreg.DocType]int, error) {
	t := time.Now()

	res0, err := r.r.CountCashFlowRegByTypeFromReleaseYesterday(ctx)

	r.w.Observe("count_cash_flow_reg_by_type_from_release_yesterday", err == nil, time.Since(t))

	return res0, err
}

func (r *repo) GetActivePayAndRefundDocsByOrderTx(ctx context.Context, tx *sql.Tx, orderGUID uuid.UUID) (map[cashflowreg.DocType][]cashflowreg.CashFlowRegisterDocInfo, error) {
	t := time.Now()

	res0, err := r.r.GetActivePayAndRefundDocsByOrderTx(ctx, tx, orderGUID)

	r.w.Observe("get_active_pay_and_refund_docs_by_order_tx", err == nil, time.Since(t))

	return res0, err
}

func (r *repo) CountSeparateBankStatementTx(ctx context.Context, tx *sql.Tx, guid uuid.UUID) (int, error) {
	t := time.Now()

	res0, err := r.r.CountSeparateBankStatementTx(ctx, tx, guid)

	r.w.Observe("count_separate_bank_statement_tx", err == nil, time.Since(t))

	return res0, err
}
