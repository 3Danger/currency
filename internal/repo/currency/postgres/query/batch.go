// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: batch.go

package query

import (
	"context"
	"errors"
	"time"

	"github.com/jackc/pgx/v5"
	"github.com/shopspring/decimal"
)

var (
	ErrBatchAlreadyClosed = errors.New("batch already closed")
)

const setCryptoPrices = `-- name: SetCryptoPrices :batchexec
INSERT INTO currency_crypto_pair (code_crypto, code_fiat, updated_at, rate)
VALUES ($1, $2, $3, $4)
ON CONFLICT (code_crypto, code_fiat) DO UPDATE
    SET updated_at = EXCLUDED.updated_at,
        rate = EXCLUDED.rate
`

type SetCryptoPricesBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type SetCryptoPricesParams struct {
	CodeCrypto CryptoCode
	CodeFiat   FiatCode
	UpdatedAt  time.Time
	Rate       decimal.Decimal
}

func (q *Queries) SetCryptoPrices(ctx context.Context, arg []SetCryptoPricesParams) *SetCryptoPricesBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.CodeCrypto,
			a.CodeFiat,
			a.UpdatedAt,
			a.Rate,
		}
		batch.Queue(setCryptoPrices, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &SetCryptoPricesBatchResults{br, len(arg), false}
}

func (b *SetCryptoPricesBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *SetCryptoPricesBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const setCurrenciesFiat = `-- name: SetCurrenciesFiat :batchexec
INSERT INTO currency_fiat (code, updated_at, rate_to_usd)
VALUES ($1, $2, $3)
ON CONFLICT (code) DO UPDATE
    SET updated_at  = EXCLUDED.updated_at,
        rate_to_usd = EXCLUDED.rate_to_usd
`

type SetCurrenciesFiatBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type SetCurrenciesFiatParams struct {
	Code      FiatCode
	UpdatedAt time.Time
	RateToUsd decimal.Decimal
}

func (q *Queries) SetCurrenciesFiat(ctx context.Context, arg []SetCurrenciesFiatParams) *SetCurrenciesFiatBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.Code,
			a.UpdatedAt,
			a.RateToUsd,
		}
		batch.Queue(setCurrenciesFiat, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &SetCurrenciesFiatBatchResults{br, len(arg), false}
}

func (b *SetCurrenciesFiatBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *SetCurrenciesFiatBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}
